<HTML>
<HEAD>
<TITLE>TSP (libtsp) - FIfConvSI</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFACD">
<H2>FIfConvSI</H2>
<HR>
<H4>Routine</H4>
<DL>
<DT>
void FIfConvSI (const float x[], float y[], int Nout, const float h[],
int Ncof, int mr, int Nsub, int Ir)
</DL>
<H4>Purpose</H4>
<DL>
<DT>
Filter a signal with an FIR filter (sample rate change)
</DL>
<H4>Description</H4>
This procedure convolves a set of filter coefficients with an array of data.
Optionally, the input signal can be interpolated before filtering, and the
output signal can be subsampled.
<P>
The process of interpolation is equivalent to the conceptual notion of
inserting Ir-1 zeros between each element of the input array.  This increased
rate signal array is convolved with the filter coefficients.  Since the
increased rate signal array has imbedded zeros, only every Ir'th filter
coefficient is involved in producing a given output point.  These
coefficients can be considered to constitute a sub-filter.  Sub-filters
are used in a round-robin fashion to produce successive output points.
<P>
The process of subsampling is equivalent to keeping only every Nsub'th output
point.  The filter slides along Nsub elements at a time in the increased rate
(interpolated) signal array for every point that is stored in the output
array.
<P>
The input array is x[.].  The first lmem = (Ncof-1)/Ir samples of x[.] are
past inputs.  Let the increased rate array be xi[.].  Then, xi[l*Ir]=x[l],
with other elements in xi[.] being zero.  The relationship between indices
of  x[l] and xi[m] is m=l*Ir+mr, or l=floor(m/Ir), mr=m-l*Ir.  The first
output point is calculated with filter coefficient h[0] aligned with sample
xi[Ir*lmem+mr], or equivalently, h[mr] aligned with sample x[lmem].  The
last output point is calculated with h[0] aligned with the sample
xi[Ir*lmem+mr+(Nout-1)*Nsub].
<P>
If Nout output values are to be calculated, the input array x[.] must have Nx
elements, where Nx is determined from
<PRE>
  lmem*Ir+mr+(Nout-1)*Nsub &lt;= Ir*Nx-1
</PRE>
From this relationship,
<PRE>
  Nx = lmem + ceil((mr+1+(Nout-1)*Nsub)/Ir)
     = lmem + floor((mr+(Nout-1)*Nsub)/Ir) + 1
</PRE>
Conversely if the input array has Nx elements, the number of output samples
that can be calculated as
<PRE>
  Nout = floor((Ir*(Nx-lmem)-1-mr)/Nsub) + 1
       = ceil((Ir*(Nx-lmem)-mr)/Nsub).
</PRE>
<H4>Parameters</H4>
<DL>
<DT>
 -&gt; const float x[]
<DD>
Input array of data.  Let lmem=(Ncof-1)/Ir.  The first output point is
calculated as follows
<PRE>
  y[0] = h[mr]*x[lmem] + h[mr+Ir]*x[lmem-1]
                       + h[mr+2*Ir]*x[lmem-2] + ...
</PRE>
The array x must have at least lmem+((Nout-1)*Nsub+mr)/Ir+1 elements.
<DT>
&lt;-  const float y[]
<DD>
Array of output samples
<DT>
 -&gt; int Nout
<DD>
Number of output samples to be calculated
<DT>
 -&gt; const float h[]
<DD>
Array of Ncof filter coefficients
<DT>
 -&gt; int Ncof
<DD>
Number of filter coefficients
<DT>
 -&gt; int mr
<DD>
Filter coefficient offset.  The first output point has filter coefficient
h[mr] aligned with data element x[lmem].  Normally mr is in the range 0
to Ir-1.
<DT>
 -&gt; int Nsub
<DD>
Subsampling ratio.  Only every Nsub'th filtered output is calculated for
the interpolated sequence and stored in the output array.
<DT>
 -&gt; int Ir
<DD>
Interpolating ratio.  Conceptually, Ir-1 zeros are inserted between each
element of the input array to create an interpolated sequence before
convolving with the filter coefficients.
</DL>
<H4>Author / revision</H4>
P. Kabal
/ Revision 1.17  2005/02/01
<H4>See Also</H4>
<A HREF="FIfConvol.html">FIfConvol</A>
<P>
<HR>
Main Index <A HREF="../libtsp.html">libtsp</A>
</BODY>
</HTML>
