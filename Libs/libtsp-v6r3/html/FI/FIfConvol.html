<HTML>
<HEAD>
<TITLE>TSP (libtsp) - FIfConvol</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFACD">
<H2>FIfConvol</H2>
<HR>
<H4>Routine</H4>
<DL>
<DT>
void FIfConvol (const float x[], float y[], int Nout, const float h[],
int Ncof)
</DL>
<H4>Purpose</H4>
<DL>
<DT>
Filter a signal with an FIR filter
</DL>
<H4>Description</H4>
The procedure convolves a set of filter coefficients with an array of data.
The input array is x[.].  The first lmem = Ncof-1 samples of x[.] are past
inputs.  The first output point is calculated with filter coefficient h[0]
aligned with x[lmem].  The last output point is calculated with h[0] aligned
with x[lmem+(Nout-1)].
<P>
The output array can share storage with the input array, with the output data
overlaying the input data.  Consider an array x[] with lmem+Nout elements.
The first lmem elements are past input samples; the next Nout values are new
input samples.  To share input/output storage, invoke this routine as
<PRE>
  FIconvol (x, x, Nout, h, Ncof)
</PRE>
On return, the first Nout elements of x[] are the output values.  The last
lmem elements are the past input values needed for the next invocation of
FIconvol.
<H4>Parameters</H4>
<DL>
<DT>
 -&gt; const float x[]
<DD>
Input array of data.  Let lmem=Ncof-1.  The first output point point is
calculated as follows
<PRE>
  y[0] = h[0]*x[lmem] + h[1]*x[lmem-1] + h[2]*x[lmem-2] + ...
</PRE>
The array x must have lmem+((Nout-1))+1 elements.
<DT>
&lt;-  float y[]
<DD>
Output array of samples.  The order of operations is such that this array
can share storage with the array x.
<DT>
 -&gt; int Nout
<DD>
Number of output samples to be calculated
<DT>
 -&gt; const float h[]
<DD>
Array of Ncof filter coefficients
<DT>
 -&gt; int Ncof
<DD>
Number of filter coefficients
</DL>
<H4>Author / revision</H4>
P. Kabal
/ Revision 1.14  2005/02/01
<H4>See Also</H4>
<A HREF="FIfConvSI.html">FIfConvSI</A>
<P>
<HR>
Main Index <A HREF="../libtsp.html">libtsp</A>
</BODY>
</HTML>
